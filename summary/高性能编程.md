#### 内容整理自文章: https://mp.weixin.qq.com/s/wUrRQYz9rueAC8A4ugBYaQ
#### 1. 反射虽好，切莫贪杯
##### 1.1 strconv vs fmt
```go
// Bad
// 反射实现
for i := 0; i < b.N; i++ {
 s := fmt.Sprint(rand.Int())
}

BenchmarkFmtSprint-4    143 ns/op    2 allocs/op

// Good
for i := 0; i < b.N; i++ {
 //     strconv.FormatInt
 s := strconv.Itoa(rand.Int())
}

BenchmarkStrconv-4    64.2 ns/op    1 allocs/op
```

##### 1.2 思考反射使用的必要性
```go
// 本段代码实际上就是想利用反射达到一定的泛型化能力，过滤掉 list 中的指定元素
func DeleteSliceElms(i interface{}, elms ...interface{}) interface{} {
 // 构建 map set。
 m := make(map[interface{}]struct{}, len(elms))
 for _, v := range elms {
  m[v] = struct{}{}
 }
 // 创建新切片，过滤掉指定元素。
 v := reflect.ValueOf(i) 
 t := reflect.MakeSlice(reflect.TypeOf(i), 0, v.Len())
 for i := 0; i < v.Len(); i++ {
  if _, ok := m[v.Index(i).Interface()]; !ok {
   t = reflect.Append(t, v.Index(i))
  }
 }
 return t.Interface()
}

// 指定具体类型
// DeleteU64liceElms 从 []uint64 过滤指定元素。注意：不修改原切片。
func DeleteU64liceElms(i []uint64, elms ...uint64) []uint64 {
 // 构建 map set。
 m := make(map[uint64]struct{}, len(elms))
 for _, v := range elms {
  m[v] = struct{}{}
 }
 // 创建新切片，过滤掉指定元素。
 t := make([]uint64, 0, len(i))
 for _, v := range i {
  if _, ok := m[v]; !ok {
   t = append(t, v)
  }
 }
 return t
}

// benchmark 显示有好几倍的性能差距
go test -bench=. -benchmem main/reflect 
goos: darwin
goarch: amd64
pkg: main/reflect
cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz
BenchmarkDeleteSliceElms-12              1226868               978.2 ns/op           296 B/op         16 allocs/op
BenchmarkDeleteU64liceElms-12            8249469               145.3 ns/op            80 B/op          1 allocs/op
PASS
ok      main/reflect    3.809s
```

##### 1.3 慎用 binary.Read 和 binary.Write
- encoding/binary 包实现了数字和字节序列之间的简单转换以及 varints 的编码和解码
- encoding/binary 包实现，引入了反射，性能较低


#### 2. 避免重复的 string <--> []byte
```go
// Bad
for i := 0; i < b.N; i++ {
 w.Write([]byte("Hello world"))
}

BenchmarkBad-4   50000000   22.2 ns/op

// Good
data := []byte("Hello world") 
for i := 0; i < b.N; i++ {
 w.Write(data)
}

BenchmarkGood-4  500000000   3.25 ns/op
```

#### 3. 指定容器容量
```go
// 1. map
// 注意: map cap 并不保证完全的抢占式分配，而是用于估计所需的 hashmap bucket 数量
make(map[T1]T2, hint)

// 2. slice
make([]T, length, capacity)

```

#### 4. 字符串拼接
- `+`：行内字符串拼接